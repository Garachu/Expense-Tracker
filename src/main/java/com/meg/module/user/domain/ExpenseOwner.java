package com.meg.module.user.domain;

import com.googlecode.objectify.Ref;
import com.googlecode.objectify.annotation.Entity;
import com.googlecode.objectify.annotation.Load;
import com.meg.module.core.BaseEntity;
import com.meg.module.expense.Expense;
import lombok.Getter;
import lombok.NonNull;

import java.util.ArrayList;
import java.util.List;


/**
 * Created by meg on 8/27/17.
 */

/**
  * https://github.com/objectify/objectify/wiki/Entities
  * Entity classes must be annotated with @Entity.
  * Objectify persists fields and only fields. It does not arbitrarily map fields to the datastore; if you want to change the name of a property in the datastore, rename the field. Getters and setters are ignored so you can isolate the public interface of your class (eg, public String getVehicleIdentificationNumber() { return vin;}).
  * Objectify will not persist static fields, final fields, or fields annotated with @Ignore. It will persist fields with the transient keyword, which only affects serialization.
  * Entities must have one field annotated with @Id. The actual name of the field is irrelevant and can be renamed at any time, even after data is persisted. This value (along with the kind 'Car') becomes part of the Key which identifies an entity.
  * The @Id field can be of type Long, long, or String. If you use Long and save an entity with a null id, a numeric value will be generated for you using the standard GAE allocator for this kind. If you use String or the primitive long type, values will never be autogenerated.
  * There must be a no-arg constructor (or no constructors - Java creates a default no-arg constructor). The no-arg constructor can have any protection level (private, public, etc).
  * String fields which store more than 500 characters (the GAE limit) are automatically converted to Text internally. Note that Text fields, like Blob fields, are never indexed (see Queries).
  * byte[] fields are automatically converted to Blob internally. However, Byte[] is persisted "normally" as an array of (potentially indexed) Byte objects. Note that GAE natively stores all integer values as a 64-bit long.
 */


@Entity
@Getter
public class ExpenseOwner extends BaseEntity {

    @NonNull
    public String label;

    @NonNull
    public String fullname;

    @NonNull
    public String description;

    private ExpenseOwner() {
        super();
    }

    /**
     * List of references to all the expenses that the ExpenseOwner owns.
     *
     * Load annotation explanation:
     * Makes for optimal batch-by-type queries to datastore, also caches it intelligently by optimalisation algorithm.
     */
    @Load
    private List<Ref<Expense>> expenses = new ArrayList<>();

    /**
     * getExpenses function iterates through the expense references and places the actual expense entities into a List that is returned
     * @return List with actual Expense entities
     */
    public List<Expense> getExpenses() {
        final List<Expense> expenseList = new ArrayList<>();

        for (final Ref<Expense> expenseRef : expenses) {
            expenseList.add(expenseRef.get());
        }

        return expenseList;
    }

    /**
     * setExpenses function sets a list of references to expenses.
     */
    public void setExpenses(final List<Expense> inputExpenseList) {
        for (final Expense expense : inputExpenseList) {
            addExpense(expense);
        }
    }

    /**
     * Private function to add a single Expense as Ref to the existing Ref List.
     */
    private void addExpense(final Expense expense) {
        expenses.add(Ref.create(expense));
    }


    @Override
    public String toString() {
        return String.format(
                "Expense_Owner[id=%s, label='%s', fullname='%s', description=%s]",
                getId(), label, fullname, description);
    }
}
