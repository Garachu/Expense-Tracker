Objectify
Objectify is a Java data access API specifically designed for the Google App Engine datastore. 
All datastore operations begin with an instance of Objectify
An Objectify instance holds the complete state of your persistence session.
An Objectify instance should be used from a single thread only
An Objectify instance is a cheap throwaway object that represents a session of activity. Typically you will re-use a single instance through a request, except when you begin transactions.
ObjectifyService.ofy() will always return the correct instance for your thread and transaction context and provides you with an "always available" persistence context without having to pass extra parameters to your business methods.
The instance returned by ofy() will change when you enter and exit transactions. Be sure to install the ObjectifyFilter so that the last instance is cleaned up at the end of a request.

The Development Server and the Datastore
The development server simulates the datastore service on your local machine while you're testing your app.
All datastore entities are saved to a local file.
The local file is associated with your app, and persists between runs of the development server, so your test data remains availbble until you delete it.
The datastore data file is named local_db.bin and is stored in the appengine-generated directory
The datastore data file local_db.bin is never deployed with the application.


Ref<?> Key<?>
In the datastore, Ref<?> and Key<?> are just native datastore keys
You can filter by the Ref/Key object, or even just pass in the entity POJO and objectify will convert this to the appropriate native datastore key.


Entity
https://github.com/objectify/objectify/wiki/Entities
Entity classes must be annotated with @Entity.
Objectify persists fields and only fields. It does not arbitrarily map fields to the datastore; if you want to change the name of a property in the datastore, rename the field. Getters and setters are ignored so you can isolate the public interface of your class (eg, public String getVehicleIdentificationNumber() { return vin;}).
Objectify will not persist static fields, final fields, or fields annotated with @Ignore. It will persist fields with the transient keyword, which only affects serialization.
Entities must have one field annotated with @Id. The actual name of the field is irrelevant and can be renamed at any time, even after data is persisted. This value (along with the kind 'Car') becomes part of the Key which identifies an entity.
The @Id field can be of type Long, long, or String. If you use Long and save an entity with a null id, a numeric value will be generated for you using the standard GAE allocator for this kind. If you use String or the primitive long type, values will never be autogenerated.
There must be a no-arg constructor (or no constructors - Java creates a default no-arg constructor). The no-arg constructor can have any protection level (private, public, etc).
String fields which store more than 500 characters (the GAE limit) are automatically converted to Text internally. Note that Text fields, like Blob fields, are never indexed (see Queries).
byte[] fields are automatically converted to Blob internally. However, Byte[] is persisted "normally" as an array of (potentially indexed) Byte objects. Note that GAE natively stores all integer values as a 64-bit long.

Generating Indexes
----------------------------
When you test and exercise your app on the development server, the development server automatically creates any Cloud Datastore indexes required to run in production
These indexes are generated in target/projectname/WEB-INF/appengine-generated/datastore-indexes-auto.xml and are automatically uploaded when you deploy your app.
Google Cloud Datastore accessed from App Engine uses indexes for every query your application makes. These indexes are updated whenever an entity changes, so the results can be returned quickly when the app makes a query. To do this, Cloud Datastore needs to know in advance which queries the application will make. You specify which indexes your app needs in a configuration file. The development server can generate the Cloud Datastore index configuration automatically as you test your app.

Using the Java Local Development Server
---------------------------------------
The App Engine SDK for Java includes a local development server for testing your application on your computer.
The local development server simulates the App Engine Java runtime environment and all of its services, including Datastore.

Configurations
-------------------------
pom.xml 	        Project settings and dependencies used by Maven.
appengine-web.xml 	Used to specify the project ID this application is deployed to, the application version, and the location of the logging.properties file used for application logging.
logging.properties 	Used to set the default log level (Error, Warning, Info, and so on).
web.xml 	        Does all the mappings required for the servlet.


Automating Tests with Postman
------------------------------------
http://blog.getpostman.com/2014/03/07/writing-automated-tests-for-apis-using-postman/
http://blog.getpostman.com/2017/07/28/api-testing-tips-from-a-postman-professional/